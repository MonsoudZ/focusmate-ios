//
// Item.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct Item: Codable, JSONEncodable, Hashable {
    public static let priorityRule = NumericRule<Int>(minimum: 0, exclusiveMinimum: false, maximum: 3, exclusiveMaximum: false, multipleOf: nil)
    public var id: Int
    public var listId: Int
    public var title: String
    public var description: String?
    public var dueAt: Date?
    public var completedAt: Date?
    public var priority: Int
    public var canBeSnoozed: Bool
    public var notificationIntervalMinutes: Int
    public var requiresExplanationIfMissed: Bool
    public var overdue: Bool
    public var minutesOverdue: Int
    public var requiresExplanation: Bool
    public var isRecurring: Bool
    public var recurrencePattern: String?
    public var recurrenceInterval: Int
    public var recurrenceDays: [Int]?
    public var locationBased: Bool
    public var locationName: String?
    public var locationLatitude: Double?
    public var locationLongitude: Double?
    public var locationRadiusMeters: Int
    public var notifyOnArrival: Bool
    public var notifyOnDeparture: Bool
    public var missedReason: String?
    public var missedReasonSubmittedAt: Date?
    public var missedReasonReviewedAt: Date?
    public var creator: UserDTO
    public var createdByCoach: Bool
    public var canEdit: Bool
    public var canDelete: Bool
    public var canComplete: Bool
    public var isVisible: Bool
    public var escalation: Escalation?
    public var hasSubtasks: Bool
    public var subtasksCount: Int
    public var subtasksCompletedCount: Int
    public var subtaskCompletionPercentage: Int
    public var createdAt: Date
    public var updatedAt: Date

    public init(id: Int, listId: Int, title: String, description: String? = nil, dueAt: Date? = nil, completedAt: Date? = nil, priority: Int, canBeSnoozed: Bool, notificationIntervalMinutes: Int, requiresExplanationIfMissed: Bool, overdue: Bool, minutesOverdue: Int, requiresExplanation: Bool, isRecurring: Bool, recurrencePattern: String? = nil, recurrenceInterval: Int, recurrenceDays: [Int]? = nil, locationBased: Bool, locationName: String? = nil, locationLatitude: Double? = nil, locationLongitude: Double? = nil, locationRadiusMeters: Int, notifyOnArrival: Bool, notifyOnDeparture: Bool, missedReason: String? = nil, missedReasonSubmittedAt: Date? = nil, missedReasonReviewedAt: Date? = nil, creator: UserDTO, createdByCoach: Bool, canEdit: Bool, canDelete: Bool, canComplete: Bool, isVisible: Bool, escalation: Escalation? = nil, hasSubtasks: Bool, subtasksCount: Int, subtasksCompletedCount: Int, subtaskCompletionPercentage: Int, createdAt: Date, updatedAt: Date) {
        self.id = id
        self.listId = listId
        self.title = title
        self.description = description
        self.dueAt = dueAt
        self.completedAt = completedAt
        self.priority = priority
        self.canBeSnoozed = canBeSnoozed
        self.notificationIntervalMinutes = notificationIntervalMinutes
        self.requiresExplanationIfMissed = requiresExplanationIfMissed
        self.overdue = overdue
        self.minutesOverdue = minutesOverdue
        self.requiresExplanation = requiresExplanation
        self.isRecurring = isRecurring
        self.recurrencePattern = recurrencePattern
        self.recurrenceInterval = recurrenceInterval
        self.recurrenceDays = recurrenceDays
        self.locationBased = locationBased
        self.locationName = locationName
        self.locationLatitude = locationLatitude
        self.locationLongitude = locationLongitude
        self.locationRadiusMeters = locationRadiusMeters
        self.notifyOnArrival = notifyOnArrival
        self.notifyOnDeparture = notifyOnDeparture
        self.missedReason = missedReason
        self.missedReasonSubmittedAt = missedReasonSubmittedAt
        self.missedReasonReviewedAt = missedReasonReviewedAt
        self.creator = creator
        self.createdByCoach = createdByCoach
        self.canEdit = canEdit
        self.canDelete = canDelete
        self.canComplete = canComplete
        self.isVisible = isVisible
        self.escalation = escalation
        self.hasSubtasks = hasSubtasks
        self.subtasksCount = subtasksCount
        self.subtasksCompletedCount = subtasksCompletedCount
        self.subtaskCompletionPercentage = subtaskCompletionPercentage
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case listId = "list_id"
        case title
        case description
        case dueAt = "due_at"
        case completedAt = "completed_at"
        case priority
        case canBeSnoozed = "can_be_snoozed"
        case notificationIntervalMinutes = "notification_interval_minutes"
        case requiresExplanationIfMissed = "requires_explanation_if_missed"
        case overdue
        case minutesOverdue = "minutes_overdue"
        case requiresExplanation = "requires_explanation"
        case isRecurring = "is_recurring"
        case recurrencePattern = "recurrence_pattern"
        case recurrenceInterval = "recurrence_interval"
        case recurrenceDays = "recurrence_days"
        case locationBased = "location_based"
        case locationName = "location_name"
        case locationLatitude = "location_latitude"
        case locationLongitude = "location_longitude"
        case locationRadiusMeters = "location_radius_meters"
        case notifyOnArrival = "notify_on_arrival"
        case notifyOnDeparture = "notify_on_departure"
        case missedReason = "missed_reason"
        case missedReasonSubmittedAt = "missed_reason_submitted_at"
        case missedReasonReviewedAt = "missed_reason_reviewed_at"
        case creator
        case createdByCoach = "created_by_coach"
        case canEdit = "can_edit"
        case canDelete = "can_delete"
        case canComplete = "can_complete"
        case isVisible = "is_visible"
        case escalation
        case hasSubtasks = "has_subtasks"
        case subtasksCount = "subtasks_count"
        case subtasksCompletedCount = "subtasks_completed_count"
        case subtaskCompletionPercentage = "subtask_completion_percentage"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(listId, forKey: .listId)
        try container.encode(title, forKey: .title)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(dueAt, forKey: .dueAt)
        try container.encodeIfPresent(completedAt, forKey: .completedAt)
        try container.encode(priority, forKey: .priority)
        try container.encode(canBeSnoozed, forKey: .canBeSnoozed)
        try container.encode(notificationIntervalMinutes, forKey: .notificationIntervalMinutes)
        try container.encode(requiresExplanationIfMissed, forKey: .requiresExplanationIfMissed)
        try container.encode(overdue, forKey: .overdue)
        try container.encode(minutesOverdue, forKey: .minutesOverdue)
        try container.encode(requiresExplanation, forKey: .requiresExplanation)
        try container.encode(isRecurring, forKey: .isRecurring)
        try container.encodeIfPresent(recurrencePattern, forKey: .recurrencePattern)
        try container.encode(recurrenceInterval, forKey: .recurrenceInterval)
        try container.encodeIfPresent(recurrenceDays, forKey: .recurrenceDays)
        try container.encode(locationBased, forKey: .locationBased)
        try container.encodeIfPresent(locationName, forKey: .locationName)
        try container.encodeIfPresent(locationLatitude, forKey: .locationLatitude)
        try container.encodeIfPresent(locationLongitude, forKey: .locationLongitude)
        try container.encode(locationRadiusMeters, forKey: .locationRadiusMeters)
        try container.encode(notifyOnArrival, forKey: .notifyOnArrival)
        try container.encode(notifyOnDeparture, forKey: .notifyOnDeparture)
        try container.encodeIfPresent(missedReason, forKey: .missedReason)
        try container.encodeIfPresent(missedReasonSubmittedAt, forKey: .missedReasonSubmittedAt)
        try container.encodeIfPresent(missedReasonReviewedAt, forKey: .missedReasonReviewedAt)
        try container.encode(creator, forKey: .creator)
        try container.encode(createdByCoach, forKey: .createdByCoach)
        try container.encode(canEdit, forKey: .canEdit)
        try container.encode(canDelete, forKey: .canDelete)
        try container.encode(canComplete, forKey: .canComplete)
        try container.encode(isVisible, forKey: .isVisible)
        try container.encodeIfPresent(escalation, forKey: .escalation)
        try container.encode(hasSubtasks, forKey: .hasSubtasks)
        try container.encode(subtasksCount, forKey: .subtasksCount)
        try container.encode(subtasksCompletedCount, forKey: .subtasksCompletedCount)
        try container.encode(subtaskCompletionPercentage, forKey: .subtaskCompletionPercentage)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
    }
}

@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension Item: Identifiable {}
